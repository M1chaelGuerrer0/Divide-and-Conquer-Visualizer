<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Divide and Conquer Visualizer</title>

    <!--Connects this HTML file to the CSS file for styling -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Main container for the whole page -->
<div class="page">

    <!-- Header section for basic di -->
    <header>
        <h1>Divide and Conquer Visualizer</h1>
    </header>

    <!-- Section: basic idea -->
    <section class="section">
        <h2>Divide and Conquer: Basic Idea</h2>
        <p>
            The divide and conquer approach involves breaking a problem into smaller subproblems.
            Once the solutions to the subproblems are found, they are combined to obtain a final solution.
        </p>
    </section>

    <!-- Section: examples -->
    <section class="section">
        <h2>Examples of Divide and Conquer</h2>
        <p>
            Some common examples of divide and conquer algorithms include
            <strong>binary search</strong> and <strong>merge sort</strong>.
        </p>
    </section>

    <!-- Section: Binary Search -->
    <section class="section">
        <h2>Binary Search</h2>
        <p>
            Binary search is a searching algorithm that finds the position of a target element
            within a <strong>sorted</strong> array. The algorithm works by repeatedly dividing
            the search interval in half.
        </p>

        <h3>Steps</h3>
        <ul>
            <li>Compare the middle element with the target element.</li>
            <li>If they are equal, the search is complete.</li>
            <li>If the target is less than the middle element, search the left half.</li>
            <li>If the target is greater than the middle element, search the right half.</li>
            <li>Repeat until the target is found or the interval is empty.</li>
        </ul>

        <h3>Time Complexity</h3>
        <ul>
            <li><strong>Best case:</strong> O(1) — target is in the middle.</li>
            <li><strong>Worst case:</strong> O(log n) — keep halving the array.</li>
        </ul>

        <!-- Button that goes to visualizer page -->
        <button class="btn" onclick="location.href='binary_search.html'">
            Open Binary Search Visualizer
        </button>

        <!-- Right side: image -->
        <div class="algo-image-box">
            <img src="examplebinary.png"
                 alt="binary search visualization"
                 class="algo-image">
        </div>
    </section>

    <!-- Section: Merge Sort -->
    <section class="section algo-section">
        <div class="algo-text">
            <h2>Merge Sort</h2>
            <p>
                Merge sort is a sorting algorithm that uses the divide and conquer approach
                to sort an array. The array is split into two halves, each half is sorted,
                and then they are merged back together.
            </p>

            <h3>Time Complexity</h3>
            <p>
                The best, worst, and average case time complexity of merge sort is
                <strong>O(n log n)</strong>. Splitting takes O(log n) and merging takes O(n).
            </p>

            <button class="btn" onclick="location.href='merge_sort.html'">
                Open Merge Sort Visualizer
            </button>
        </div>

        <!-- Right side: image -->
        <div class="algo-image-box">
            <img src="examplemerge.png"
                 alt="merge sort visualization"
                 class="algo-image">
        </div>
    </section>

</div>
</body>
</html>
